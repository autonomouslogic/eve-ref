/* tslint:disable */
/* eslint-disable */
/**
 * EVE Stable Infrastructure (ESI) - tranquility
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2025-12-16
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CharactersCharacterIdOrdersGetInner,
  CharactersCharacterIdOrdersHistoryGetInner,
  CorporationsCorporationIdOrdersGetInner,
  CorporationsCorporationIdOrdersHistoryGetInner,
  MarketsGroupsMarketGroupIdGet,
  MarketsPricesGetInner,
  MarketsRegionIdHistoryGetInner,
  MarketsRegionIdOrdersGetInner,
  MarketsStructuresStructureIdGetInner,
} from '../models/index';
import {
    CharactersCharacterIdOrdersGetInnerFromJSON,
    CharactersCharacterIdOrdersGetInnerToJSON,
    CharactersCharacterIdOrdersHistoryGetInnerFromJSON,
    CharactersCharacterIdOrdersHistoryGetInnerToJSON,
    CorporationsCorporationIdOrdersGetInnerFromJSON,
    CorporationsCorporationIdOrdersGetInnerToJSON,
    CorporationsCorporationIdOrdersHistoryGetInnerFromJSON,
    CorporationsCorporationIdOrdersHistoryGetInnerToJSON,
    MarketsGroupsMarketGroupIdGetFromJSON,
    MarketsGroupsMarketGroupIdGetToJSON,
    MarketsPricesGetInnerFromJSON,
    MarketsPricesGetInnerToJSON,
    MarketsRegionIdHistoryGetInnerFromJSON,
    MarketsRegionIdHistoryGetInnerToJSON,
    MarketsRegionIdOrdersGetInnerFromJSON,
    MarketsRegionIdOrdersGetInnerToJSON,
    MarketsStructuresStructureIdGetInnerFromJSON,
    MarketsStructuresStructureIdGetInnerToJSON,
} from '../models/index';

export interface GetCharactersCharacterIdOrdersRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdOrdersXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdOrdersAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdOrdersHistoryRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdOrdersHistoryXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetCharactersCharacterIdOrdersHistoryAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCorporationsCorporationIdOrdersRequest {
    corporationId: number;
    xCompatibilityDate: GetCorporationsCorporationIdOrdersXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetCorporationsCorporationIdOrdersAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCorporationsCorporationIdOrdersHistoryRequest {
    corporationId: number;
    xCompatibilityDate: GetCorporationsCorporationIdOrdersHistoryXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetCorporationsCorporationIdOrdersHistoryAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsGroupsRequest {
    xCompatibilityDate: GetMarketsGroupsXCompatibilityDateEnum;
    acceptLanguage?: GetMarketsGroupsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsGroupsMarketGroupIdRequest {
    marketGroupId: number;
    xCompatibilityDate: GetMarketsGroupsMarketGroupIdXCompatibilityDateEnum;
    acceptLanguage?: GetMarketsGroupsMarketGroupIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsPricesRequest {
    xCompatibilityDate: GetMarketsPricesXCompatibilityDateEnum;
    acceptLanguage?: GetMarketsPricesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsRegionIdHistoryRequest {
    regionId: number;
    typeId: number;
    xCompatibilityDate: GetMarketsRegionIdHistoryXCompatibilityDateEnum;
    acceptLanguage?: GetMarketsRegionIdHistoryAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsRegionIdOrdersRequest {
    orderType: GetMarketsRegionIdOrdersOrderTypeEnum;
    regionId: number;
    xCompatibilityDate: GetMarketsRegionIdOrdersXCompatibilityDateEnum;
    page?: number;
    typeId?: number;
    acceptLanguage?: GetMarketsRegionIdOrdersAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsRegionIdTypesRequest {
    regionId: number;
    xCompatibilityDate: GetMarketsRegionIdTypesXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetMarketsRegionIdTypesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetMarketsStructuresStructureIdRequest {
    structureId: number;
    xCompatibilityDate: GetMarketsStructuresStructureIdXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetMarketsStructuresStructureIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

/**
 * 
 */
export class MarketApi extends runtime.BaseAPI {

    /**
     * List open market orders placed by a character
     * List open orders from a character
     */
    async getCharactersCharacterIdOrdersRaw(requestParameters: GetCharactersCharacterIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdOrdersGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdOrders().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdOrders().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-markets.read_character_orders.v1"]);
        }


        let urlPath = `/characters/{character_id}/orders`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdOrdersGetInnerFromJSON));
    }

    /**
     * List open market orders placed by a character
     * List open orders from a character
     */
    async getCharactersCharacterIdOrders(requestParameters: GetCharactersCharacterIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdOrdersGetInner>> {
        const response = await this.getCharactersCharacterIdOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.
     * List historical orders by a character
     */
    async getCharactersCharacterIdOrdersHistoryRaw(requestParameters: GetCharactersCharacterIdOrdersHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdOrdersHistoryGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdOrdersHistory().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdOrdersHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-markets.read_character_orders.v1"]);
        }


        let urlPath = `/characters/{character_id}/orders/history`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdOrdersHistoryGetInnerFromJSON));
    }

    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.
     * List historical orders by a character
     */
    async getCharactersCharacterIdOrdersHistory(requestParameters: GetCharactersCharacterIdOrdersHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdOrdersHistoryGetInner>> {
        const response = await this.getCharactersCharacterIdOrdersHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List open market orders placed on behalf of a corporation
     * List open orders from a corporation
     */
    async getCorporationsCorporationIdOrdersRaw(requestParameters: GetCorporationsCorporationIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CorporationsCorporationIdOrdersGetInner>>> {
        if (requestParameters['corporationId'] == null) {
            throw new runtime.RequiredError(
                'corporationId',
                'Required parameter "corporationId" was null or undefined when calling getCorporationsCorporationIdOrders().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCorporationsCorporationIdOrders().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-markets.read_corporation_orders.v1"]);
        }


        let urlPath = `/corporations/{corporation_id}/orders`;
        urlPath = urlPath.replace(`{${"corporation_id"}}`, encodeURIComponent(String(requestParameters['corporationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CorporationsCorporationIdOrdersGetInnerFromJSON));
    }

    /**
     * List open market orders placed on behalf of a corporation
     * List open orders from a corporation
     */
    async getCorporationsCorporationIdOrders(requestParameters: GetCorporationsCorporationIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CorporationsCorporationIdOrdersGetInner>> {
        const response = await this.getCorporationsCorporationIdOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.
     * List historical orders from a corporation
     */
    async getCorporationsCorporationIdOrdersHistoryRaw(requestParameters: GetCorporationsCorporationIdOrdersHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CorporationsCorporationIdOrdersHistoryGetInner>>> {
        if (requestParameters['corporationId'] == null) {
            throw new runtime.RequiredError(
                'corporationId',
                'Required parameter "corporationId" was null or undefined when calling getCorporationsCorporationIdOrdersHistory().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCorporationsCorporationIdOrdersHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-markets.read_corporation_orders.v1"]);
        }


        let urlPath = `/corporations/{corporation_id}/orders/history`;
        urlPath = urlPath.replace(`{${"corporation_id"}}`, encodeURIComponent(String(requestParameters['corporationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CorporationsCorporationIdOrdersHistoryGetInnerFromJSON));
    }

    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.
     * List historical orders from a corporation
     */
    async getCorporationsCorporationIdOrdersHistory(requestParameters: GetCorporationsCorporationIdOrdersHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CorporationsCorporationIdOrdersHistoryGetInner>> {
        const response = await this.getCorporationsCorporationIdOrdersHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of item groups  This route expires daily at 11:05
     * Get item groups
     */
    async getMarketsGroupsRaw(requestParameters: GetMarketsGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsGroups().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/groups`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of item groups  This route expires daily at 11:05
     * Get item groups
     */
    async getMarketsGroups(requestParameters: GetMarketsGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getMarketsGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on an item group  This route expires daily at 11:05
     * Get item group information
     */
    async getMarketsGroupsMarketGroupIdRaw(requestParameters: GetMarketsGroupsMarketGroupIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarketsGroupsMarketGroupIdGet>> {
        if (requestParameters['marketGroupId'] == null) {
            throw new runtime.RequiredError(
                'marketGroupId',
                'Required parameter "marketGroupId" was null or undefined when calling getMarketsGroupsMarketGroupId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsGroupsMarketGroupId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/groups/{market_group_id}`;
        urlPath = urlPath.replace(`{${"market_group_id"}}`, encodeURIComponent(String(requestParameters['marketGroupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MarketsGroupsMarketGroupIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on an item group  This route expires daily at 11:05
     * Get item group information
     */
    async getMarketsGroupsMarketGroupId(requestParameters: GetMarketsGroupsMarketGroupIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarketsGroupsMarketGroupIdGet> {
        const response = await this.getMarketsGroupsMarketGroupIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of prices
     * List market prices
     */
    async getMarketsPricesRaw(requestParameters: GetMarketsPricesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MarketsPricesGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsPrices().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/prices`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MarketsPricesGetInnerFromJSON));
    }

    /**
     * Return a list of prices
     * List market prices
     */
    async getMarketsPrices(requestParameters: GetMarketsPricesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MarketsPricesGetInner>> {
        const response = await this.getMarketsPricesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of historical market statistics for the specified type in a region  This route expires daily at 11:05
     * List historical market statistics in a region
     */
    async getMarketsRegionIdHistoryRaw(requestParameters: GetMarketsRegionIdHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MarketsRegionIdHistoryGetInner>>> {
        if (requestParameters['regionId'] == null) {
            throw new runtime.RequiredError(
                'regionId',
                'Required parameter "regionId" was null or undefined when calling getMarketsRegionIdHistory().'
            );
        }

        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling getMarketsRegionIdHistory().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsRegionIdHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['typeId'] != null) {
            queryParameters['type_id'] = requestParameters['typeId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/{region_id}/history`;
        urlPath = urlPath.replace(`{${"region_id"}}`, encodeURIComponent(String(requestParameters['regionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MarketsRegionIdHistoryGetInnerFromJSON));
    }

    /**
     * Return a list of historical market statistics for the specified type in a region  This route expires daily at 11:05
     * List historical market statistics in a region
     */
    async getMarketsRegionIdHistory(requestParameters: GetMarketsRegionIdHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MarketsRegionIdHistoryGetInner>> {
        const response = await this.getMarketsRegionIdHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of orders in a region
     * List orders in a region
     */
    async getMarketsRegionIdOrdersRaw(requestParameters: GetMarketsRegionIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MarketsRegionIdOrdersGetInner>>> {
        if (requestParameters['orderType'] == null) {
            throw new runtime.RequiredError(
                'orderType',
                'Required parameter "orderType" was null or undefined when calling getMarketsRegionIdOrders().'
            );
        }

        if (requestParameters['regionId'] == null) {
            throw new runtime.RequiredError(
                'regionId',
                'Required parameter "regionId" was null or undefined when calling getMarketsRegionIdOrders().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsRegionIdOrders().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['orderType'] != null) {
            queryParameters['order_type'] = requestParameters['orderType'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['typeId'] != null) {
            queryParameters['type_id'] = requestParameters['typeId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/{region_id}/orders`;
        urlPath = urlPath.replace(`{${"region_id"}}`, encodeURIComponent(String(requestParameters['regionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MarketsRegionIdOrdersGetInnerFromJSON));
    }

    /**
     * Return a list of orders in a region
     * List orders in a region
     */
    async getMarketsRegionIdOrders(requestParameters: GetMarketsRegionIdOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MarketsRegionIdOrdersGetInner>> {
        const response = await this.getMarketsRegionIdOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.
     * List type IDs relevant to a market
     */
    async getMarketsRegionIdTypesRaw(requestParameters: GetMarketsRegionIdTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['regionId'] == null) {
            throw new runtime.RequiredError(
                'regionId',
                'Required parameter "regionId" was null or undefined when calling getMarketsRegionIdTypes().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsRegionIdTypes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/markets/{region_id}/types`;
        urlPath = urlPath.replace(`{${"region_id"}}`, encodeURIComponent(String(requestParameters['regionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.
     * List type IDs relevant to a market
     */
    async getMarketsRegionIdTypes(requestParameters: GetMarketsRegionIdTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getMarketsRegionIdTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all orders in a structure
     * List orders in a structure
     */
    async getMarketsStructuresStructureIdRaw(requestParameters: GetMarketsStructuresStructureIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MarketsStructuresStructureIdGetInner>>> {
        if (requestParameters['structureId'] == null) {
            throw new runtime.RequiredError(
                'structureId',
                'Required parameter "structureId" was null or undefined when calling getMarketsStructuresStructureId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getMarketsStructuresStructureId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-markets.structure_markets.v1"]);
        }


        let urlPath = `/markets/structures/{structure_id}`;
        urlPath = urlPath.replace(`{${"structure_id"}}`, encodeURIComponent(String(requestParameters['structureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MarketsStructuresStructureIdGetInnerFromJSON));
    }

    /**
     * Return all orders in a structure
     * List orders in a structure
     */
    async getMarketsStructuresStructureId(requestParameters: GetMarketsStructuresStructureIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MarketsStructuresStructureIdGetInner>> {
        const response = await this.getMarketsStructuresStructureIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetCharactersCharacterIdOrdersXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdOrdersXCompatibilityDateEnum = typeof GetCharactersCharacterIdOrdersXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdOrdersXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdOrdersAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdOrdersAcceptLanguageEnum = typeof GetCharactersCharacterIdOrdersAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdOrdersAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdOrdersHistoryXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdOrdersHistoryXCompatibilityDateEnum = typeof GetCharactersCharacterIdOrdersHistoryXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdOrdersHistoryXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdOrdersHistoryAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdOrdersHistoryAcceptLanguageEnum = typeof GetCharactersCharacterIdOrdersHistoryAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdOrdersHistoryAcceptLanguageEnum];
/**
 * @export
 */
export const GetCorporationsCorporationIdOrdersXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCorporationsCorporationIdOrdersXCompatibilityDateEnum = typeof GetCorporationsCorporationIdOrdersXCompatibilityDateEnum[keyof typeof GetCorporationsCorporationIdOrdersXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCorporationsCorporationIdOrdersAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCorporationsCorporationIdOrdersAcceptLanguageEnum = typeof GetCorporationsCorporationIdOrdersAcceptLanguageEnum[keyof typeof GetCorporationsCorporationIdOrdersAcceptLanguageEnum];
/**
 * @export
 */
export const GetCorporationsCorporationIdOrdersHistoryXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCorporationsCorporationIdOrdersHistoryXCompatibilityDateEnum = typeof GetCorporationsCorporationIdOrdersHistoryXCompatibilityDateEnum[keyof typeof GetCorporationsCorporationIdOrdersHistoryXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCorporationsCorporationIdOrdersHistoryAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCorporationsCorporationIdOrdersHistoryAcceptLanguageEnum = typeof GetCorporationsCorporationIdOrdersHistoryAcceptLanguageEnum[keyof typeof GetCorporationsCorporationIdOrdersHistoryAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsGroupsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsGroupsXCompatibilityDateEnum = typeof GetMarketsGroupsXCompatibilityDateEnum[keyof typeof GetMarketsGroupsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsGroupsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsGroupsAcceptLanguageEnum = typeof GetMarketsGroupsAcceptLanguageEnum[keyof typeof GetMarketsGroupsAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsGroupsMarketGroupIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsGroupsMarketGroupIdXCompatibilityDateEnum = typeof GetMarketsGroupsMarketGroupIdXCompatibilityDateEnum[keyof typeof GetMarketsGroupsMarketGroupIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsGroupsMarketGroupIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsGroupsMarketGroupIdAcceptLanguageEnum = typeof GetMarketsGroupsMarketGroupIdAcceptLanguageEnum[keyof typeof GetMarketsGroupsMarketGroupIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsPricesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsPricesXCompatibilityDateEnum = typeof GetMarketsPricesXCompatibilityDateEnum[keyof typeof GetMarketsPricesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsPricesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsPricesAcceptLanguageEnum = typeof GetMarketsPricesAcceptLanguageEnum[keyof typeof GetMarketsPricesAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsRegionIdHistoryXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsRegionIdHistoryXCompatibilityDateEnum = typeof GetMarketsRegionIdHistoryXCompatibilityDateEnum[keyof typeof GetMarketsRegionIdHistoryXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsRegionIdHistoryAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsRegionIdHistoryAcceptLanguageEnum = typeof GetMarketsRegionIdHistoryAcceptLanguageEnum[keyof typeof GetMarketsRegionIdHistoryAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsRegionIdOrdersOrderTypeEnum = {
    Buy: 'buy',
    Sell: 'sell',
    All: 'all'
} as const;
export type GetMarketsRegionIdOrdersOrderTypeEnum = typeof GetMarketsRegionIdOrdersOrderTypeEnum[keyof typeof GetMarketsRegionIdOrdersOrderTypeEnum];
/**
 * @export
 */
export const GetMarketsRegionIdOrdersXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsRegionIdOrdersXCompatibilityDateEnum = typeof GetMarketsRegionIdOrdersXCompatibilityDateEnum[keyof typeof GetMarketsRegionIdOrdersXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsRegionIdOrdersAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsRegionIdOrdersAcceptLanguageEnum = typeof GetMarketsRegionIdOrdersAcceptLanguageEnum[keyof typeof GetMarketsRegionIdOrdersAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsRegionIdTypesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsRegionIdTypesXCompatibilityDateEnum = typeof GetMarketsRegionIdTypesXCompatibilityDateEnum[keyof typeof GetMarketsRegionIdTypesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsRegionIdTypesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsRegionIdTypesAcceptLanguageEnum = typeof GetMarketsRegionIdTypesAcceptLanguageEnum[keyof typeof GetMarketsRegionIdTypesAcceptLanguageEnum];
/**
 * @export
 */
export const GetMarketsStructuresStructureIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetMarketsStructuresStructureIdXCompatibilityDateEnum = typeof GetMarketsStructuresStructureIdXCompatibilityDateEnum[keyof typeof GetMarketsStructuresStructureIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetMarketsStructuresStructureIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsStructuresStructureIdAcceptLanguageEnum = typeof GetMarketsStructuresStructureIdAcceptLanguageEnum[keyof typeof GetMarketsStructuresStructureIdAcceptLanguageEnum];
