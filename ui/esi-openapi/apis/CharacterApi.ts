/* tslint:disable */
/* eslint-disable */
/**
 * EVE Stable Infrastructure (ESI) - tranquility
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2025-12-16
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CharactersAffiliationPostInner,
  CharactersCharacterIdAgentsResearchGetInner,
  CharactersCharacterIdBlueprintsGetInner,
  CharactersCharacterIdCorporationhistoryGetInner,
  CharactersCharacterIdFatigueGet,
  CharactersCharacterIdGet,
  CharactersCharacterIdMedalsGetInner,
  CharactersCharacterIdNotificationsContactsGetInner,
  CharactersCharacterIdNotificationsGetInner,
  CharactersCharacterIdPortraitGet,
  CharactersCharacterIdRolesGet,
  CharactersCharacterIdStandingsGetInner,
  CharactersCharacterIdTitlesGetInner,
} from '../models/index';
import {
    CharactersAffiliationPostInnerFromJSON,
    CharactersAffiliationPostInnerToJSON,
    CharactersCharacterIdAgentsResearchGetInnerFromJSON,
    CharactersCharacterIdAgentsResearchGetInnerToJSON,
    CharactersCharacterIdBlueprintsGetInnerFromJSON,
    CharactersCharacterIdBlueprintsGetInnerToJSON,
    CharactersCharacterIdCorporationhistoryGetInnerFromJSON,
    CharactersCharacterIdCorporationhistoryGetInnerToJSON,
    CharactersCharacterIdFatigueGetFromJSON,
    CharactersCharacterIdFatigueGetToJSON,
    CharactersCharacterIdGetFromJSON,
    CharactersCharacterIdGetToJSON,
    CharactersCharacterIdMedalsGetInnerFromJSON,
    CharactersCharacterIdMedalsGetInnerToJSON,
    CharactersCharacterIdNotificationsContactsGetInnerFromJSON,
    CharactersCharacterIdNotificationsContactsGetInnerToJSON,
    CharactersCharacterIdNotificationsGetInnerFromJSON,
    CharactersCharacterIdNotificationsGetInnerToJSON,
    CharactersCharacterIdPortraitGetFromJSON,
    CharactersCharacterIdPortraitGetToJSON,
    CharactersCharacterIdRolesGetFromJSON,
    CharactersCharacterIdRolesGetToJSON,
    CharactersCharacterIdStandingsGetInnerFromJSON,
    CharactersCharacterIdStandingsGetInnerToJSON,
    CharactersCharacterIdTitlesGetInnerFromJSON,
    CharactersCharacterIdTitlesGetInnerToJSON,
} from '../models/index';

export interface GetCharactersCharacterIdRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdAgentsResearchRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdAgentsResearchXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdAgentsResearchAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdBlueprintsRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdBlueprintsXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetCharactersCharacterIdBlueprintsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdCorporationhistoryRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdCorporationhistoryXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdCorporationhistoryAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdFatigueRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdFatigueXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdFatigueAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdMedalsRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdMedalsXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdMedalsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdNotificationsRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdNotificationsXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdNotificationsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdNotificationsContactsRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdNotificationsContactsXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdNotificationsContactsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdPortraitRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdPortraitXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdPortraitAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdRolesRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdRolesXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdRolesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdStandingsRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdStandingsXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdStandingsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetCharactersCharacterIdTitlesRequest {
    characterId: number;
    xCompatibilityDate: GetCharactersCharacterIdTitlesXCompatibilityDateEnum;
    acceptLanguage?: GetCharactersCharacterIdTitlesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface PostCharactersAffiliationRequest {
    xCompatibilityDate: PostCharactersAffiliationXCompatibilityDateEnum;
    requestBody: Set<number>;
    acceptLanguage?: PostCharactersAffiliationAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface PostCharactersCharacterIdCspaRequest {
    characterId: number;
    xCompatibilityDate: PostCharactersCharacterIdCspaXCompatibilityDateEnum;
    requestBody: Set<number>;
    acceptLanguage?: PostCharactersCharacterIdCspaAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

/**
 * 
 */
export class CharacterApi extends runtime.BaseAPI {

    /**
     * Public information about a character
     * Get character\'s public information
     */
    async getCharactersCharacterIdRaw(requestParameters: GetCharactersCharacterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CharactersCharacterIdGet>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/characters/{character_id}`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CharactersCharacterIdGetFromJSON(jsonValue));
    }

    /**
     * Public information about a character
     * Get character\'s public information
     */
    async getCharactersCharacterId(requestParameters: GetCharactersCharacterIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CharactersCharacterIdGet> {
        const response = await this.getCharactersCharacterIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)
     * Get agents research
     */
    async getCharactersCharacterIdAgentsResearchRaw(requestParameters: GetCharactersCharacterIdAgentsResearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdAgentsResearchGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdAgentsResearch().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdAgentsResearch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_agents_research.v1"]);
        }


        let urlPath = `/characters/{character_id}/agents_research`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdAgentsResearchGetInnerFromJSON));
    }

    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)
     * Get agents research
     */
    async getCharactersCharacterIdAgentsResearch(requestParameters: GetCharactersCharacterIdAgentsResearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdAgentsResearchGetInner>> {
        const response = await this.getCharactersCharacterIdAgentsResearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of blueprints the character owns
     * Get blueprints
     */
    async getCharactersCharacterIdBlueprintsRaw(requestParameters: GetCharactersCharacterIdBlueprintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdBlueprintsGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdBlueprints().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdBlueprints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_blueprints.v1"]);
        }


        let urlPath = `/characters/{character_id}/blueprints`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdBlueprintsGetInnerFromJSON));
    }

    /**
     * Return a list of blueprints the character owns
     * Get blueprints
     */
    async getCharactersCharacterIdBlueprints(requestParameters: GetCharactersCharacterIdBlueprintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdBlueprintsGetInner>> {
        const response = await this.getCharactersCharacterIdBlueprintsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all the corporations a character has been a member of
     * Get corporation history
     */
    async getCharactersCharacterIdCorporationhistoryRaw(requestParameters: GetCharactersCharacterIdCorporationhistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdCorporationhistoryGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdCorporationhistory().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdCorporationhistory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/characters/{character_id}/corporationhistory`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdCorporationhistoryGetInnerFromJSON));
    }

    /**
     * Get a list of all the corporations a character has been a member of
     * Get corporation history
     */
    async getCharactersCharacterIdCorporationhistory(requestParameters: GetCharactersCharacterIdCorporationhistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdCorporationhistoryGetInner>> {
        const response = await this.getCharactersCharacterIdCorporationhistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a character\'s jump activation and fatigue information
     * Get jump fatigue
     */
    async getCharactersCharacterIdFatigueRaw(requestParameters: GetCharactersCharacterIdFatigueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CharactersCharacterIdFatigueGet>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdFatigue().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdFatigue().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_fatigue.v1"]);
        }


        let urlPath = `/characters/{character_id}/fatigue`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CharactersCharacterIdFatigueGetFromJSON(jsonValue));
    }

    /**
     * Return a character\'s jump activation and fatigue information
     * Get jump fatigue
     */
    async getCharactersCharacterIdFatigue(requestParameters: GetCharactersCharacterIdFatigueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CharactersCharacterIdFatigueGet> {
        const response = await this.getCharactersCharacterIdFatigueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of medals the character has
     * Get medals
     */
    async getCharactersCharacterIdMedalsRaw(requestParameters: GetCharactersCharacterIdMedalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdMedalsGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdMedals().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdMedals().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_medals.v1"]);
        }


        let urlPath = `/characters/{character_id}/medals`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdMedalsGetInnerFromJSON));
    }

    /**
     * Return a list of medals the character has
     * Get medals
     */
    async getCharactersCharacterIdMedals(requestParameters: GetCharactersCharacterIdMedalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdMedalsGetInner>> {
        const response = await this.getCharactersCharacterIdMedalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return character notifications
     * Get character notifications
     */
    async getCharactersCharacterIdNotificationsRaw(requestParameters: GetCharactersCharacterIdNotificationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdNotificationsGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdNotifications().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdNotifications().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_notifications.v1"]);
        }


        let urlPath = `/characters/{character_id}/notifications`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdNotificationsGetInnerFromJSON));
    }

    /**
     * Return character notifications
     * Get character notifications
     */
    async getCharactersCharacterIdNotifications(requestParameters: GetCharactersCharacterIdNotificationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdNotificationsGetInner>> {
        const response = await this.getCharactersCharacterIdNotificationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return notifications about having been added to someone\'s contact list
     * Get new contact notifications
     */
    async getCharactersCharacterIdNotificationsContactsRaw(requestParameters: GetCharactersCharacterIdNotificationsContactsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdNotificationsContactsGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdNotificationsContacts().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdNotificationsContacts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_notifications.v1"]);
        }


        let urlPath = `/characters/{character_id}/notifications/contacts`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdNotificationsContactsGetInnerFromJSON));
    }

    /**
     * Return notifications about having been added to someone\'s contact list
     * Get new contact notifications
     */
    async getCharactersCharacterIdNotificationsContacts(requestParameters: GetCharactersCharacterIdNotificationsContactsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdNotificationsContactsGetInner>> {
        const response = await this.getCharactersCharacterIdNotificationsContactsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get portrait urls for a character  This route expires daily at 11:05
     * Get character portraits
     */
    async getCharactersCharacterIdPortraitRaw(requestParameters: GetCharactersCharacterIdPortraitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CharactersCharacterIdPortraitGet>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdPortrait().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdPortrait().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/characters/{character_id}/portrait`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CharactersCharacterIdPortraitGetFromJSON(jsonValue));
    }

    /**
     * Get portrait urls for a character  This route expires daily at 11:05
     * Get character portraits
     */
    async getCharactersCharacterIdPortrait(requestParameters: GetCharactersCharacterIdPortraitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CharactersCharacterIdPortraitGet> {
        const response = await this.getCharactersCharacterIdPortraitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a character\'s corporation roles
     * Get character corporation roles
     */
    async getCharactersCharacterIdRolesRaw(requestParameters: GetCharactersCharacterIdRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CharactersCharacterIdRolesGet>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdRoles().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_corporation_roles.v1"]);
        }


        let urlPath = `/characters/{character_id}/roles`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CharactersCharacterIdRolesGetFromJSON(jsonValue));
    }

    /**
     * Returns a character\'s corporation roles
     * Get character corporation roles
     */
    async getCharactersCharacterIdRoles(requestParameters: GetCharactersCharacterIdRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CharactersCharacterIdRolesGet> {
        const response = await this.getCharactersCharacterIdRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return character standings from agents, NPC corporations, and factions
     * Get standings
     */
    async getCharactersCharacterIdStandingsRaw(requestParameters: GetCharactersCharacterIdStandingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdStandingsGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdStandings().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdStandings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_standings.v1"]);
        }


        let urlPath = `/characters/{character_id}/standings`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdStandingsGetInnerFromJSON));
    }

    /**
     * Return character standings from agents, NPC corporations, and factions
     * Get standings
     */
    async getCharactersCharacterIdStandings(requestParameters: GetCharactersCharacterIdStandingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdStandingsGetInner>> {
        const response = await this.getCharactersCharacterIdStandingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a character\'s titles
     * Get character corporation titles
     */
    async getCharactersCharacterIdTitlesRaw(requestParameters: GetCharactersCharacterIdTitlesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersCharacterIdTitlesGetInner>>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling getCharactersCharacterIdTitles().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getCharactersCharacterIdTitles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_titles.v1"]);
        }


        let urlPath = `/characters/{character_id}/titles`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersCharacterIdTitlesGetInnerFromJSON));
    }

    /**
     * Returns a character\'s titles
     * Get character corporation titles
     */
    async getCharactersCharacterIdTitles(requestParameters: GetCharactersCharacterIdTitlesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersCharacterIdTitlesGetInner>> {
        const response = await this.getCharactersCharacterIdTitlesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk lookup of character IDs to corporation, alliance and faction
     * Character affiliation
     */
    async postCharactersAffiliationRaw(requestParameters: PostCharactersAffiliationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CharactersAffiliationPostInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling postCharactersAffiliation().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling postCharactersAffiliation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/characters/affiliation`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CharactersAffiliationPostInnerFromJSON));
    }

    /**
     * Bulk lookup of character IDs to corporation, alliance and faction
     * Character affiliation
     */
    async postCharactersAffiliation(requestParameters: PostCharactersAffiliationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CharactersAffiliationPostInner>> {
        const response = await this.postCharactersAffiliationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost
     * Calculate a CSPA charge cost
     */
    async postCharactersCharacterIdCspaRaw(requestParameters: PostCharactersCharacterIdCspaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters['characterId'] == null) {
            throw new runtime.RequiredError(
                'characterId',
                'Required parameter "characterId" was null or undefined when calling postCharactersCharacterIdCspa().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling postCharactersCharacterIdCspa().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling postCharactersCharacterIdCspa().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-characters.read_contacts.v1"]);
        }


        let urlPath = `/characters/{character_id}/cspa`;
        urlPath = urlPath.replace(`{${"character_id"}}`, encodeURIComponent(String(requestParameters['characterId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost
     * Calculate a CSPA charge cost
     */
    async postCharactersCharacterIdCspa(requestParameters: PostCharactersCharacterIdCspaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.postCharactersCharacterIdCspaRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetCharactersCharacterIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdXCompatibilityDateEnum = typeof GetCharactersCharacterIdXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdAcceptLanguageEnum = typeof GetCharactersCharacterIdAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdAgentsResearchXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdAgentsResearchXCompatibilityDateEnum = typeof GetCharactersCharacterIdAgentsResearchXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdAgentsResearchXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdAgentsResearchAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdAgentsResearchAcceptLanguageEnum = typeof GetCharactersCharacterIdAgentsResearchAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdAgentsResearchAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdBlueprintsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdBlueprintsXCompatibilityDateEnum = typeof GetCharactersCharacterIdBlueprintsXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdBlueprintsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdBlueprintsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdBlueprintsAcceptLanguageEnum = typeof GetCharactersCharacterIdBlueprintsAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdBlueprintsAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdCorporationhistoryXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdCorporationhistoryXCompatibilityDateEnum = typeof GetCharactersCharacterIdCorporationhistoryXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdCorporationhistoryXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdCorporationhistoryAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdCorporationhistoryAcceptLanguageEnum = typeof GetCharactersCharacterIdCorporationhistoryAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdCorporationhistoryAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdFatigueXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdFatigueXCompatibilityDateEnum = typeof GetCharactersCharacterIdFatigueXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdFatigueXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdFatigueAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdFatigueAcceptLanguageEnum = typeof GetCharactersCharacterIdFatigueAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdFatigueAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdMedalsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdMedalsXCompatibilityDateEnum = typeof GetCharactersCharacterIdMedalsXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdMedalsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdMedalsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdMedalsAcceptLanguageEnum = typeof GetCharactersCharacterIdMedalsAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdMedalsAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdNotificationsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdNotificationsXCompatibilityDateEnum = typeof GetCharactersCharacterIdNotificationsXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdNotificationsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdNotificationsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdNotificationsAcceptLanguageEnum = typeof GetCharactersCharacterIdNotificationsAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdNotificationsAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdNotificationsContactsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdNotificationsContactsXCompatibilityDateEnum = typeof GetCharactersCharacterIdNotificationsContactsXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdNotificationsContactsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdNotificationsContactsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdNotificationsContactsAcceptLanguageEnum = typeof GetCharactersCharacterIdNotificationsContactsAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdNotificationsContactsAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdPortraitXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdPortraitXCompatibilityDateEnum = typeof GetCharactersCharacterIdPortraitXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdPortraitXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdPortraitAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdPortraitAcceptLanguageEnum = typeof GetCharactersCharacterIdPortraitAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdPortraitAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdRolesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdRolesXCompatibilityDateEnum = typeof GetCharactersCharacterIdRolesXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdRolesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdRolesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdRolesAcceptLanguageEnum = typeof GetCharactersCharacterIdRolesAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdRolesAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdStandingsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdStandingsXCompatibilityDateEnum = typeof GetCharactersCharacterIdStandingsXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdStandingsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdStandingsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdStandingsAcceptLanguageEnum = typeof GetCharactersCharacterIdStandingsAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdStandingsAcceptLanguageEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdTitlesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetCharactersCharacterIdTitlesXCompatibilityDateEnum = typeof GetCharactersCharacterIdTitlesXCompatibilityDateEnum[keyof typeof GetCharactersCharacterIdTitlesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetCharactersCharacterIdTitlesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdTitlesAcceptLanguageEnum = typeof GetCharactersCharacterIdTitlesAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdTitlesAcceptLanguageEnum];
/**
 * @export
 */
export const PostCharactersAffiliationXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type PostCharactersAffiliationXCompatibilityDateEnum = typeof PostCharactersAffiliationXCompatibilityDateEnum[keyof typeof PostCharactersAffiliationXCompatibilityDateEnum];
/**
 * @export
 */
export const PostCharactersAffiliationAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostCharactersAffiliationAcceptLanguageEnum = typeof PostCharactersAffiliationAcceptLanguageEnum[keyof typeof PostCharactersAffiliationAcceptLanguageEnum];
/**
 * @export
 */
export const PostCharactersCharacterIdCspaXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type PostCharactersCharacterIdCspaXCompatibilityDateEnum = typeof PostCharactersCharacterIdCspaXCompatibilityDateEnum[keyof typeof PostCharactersCharacterIdCspaXCompatibilityDateEnum];
/**
 * @export
 */
export const PostCharactersCharacterIdCspaAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostCharactersCharacterIdCspaAcceptLanguageEnum = typeof PostCharactersCharacterIdCspaAcceptLanguageEnum[keyof typeof PostCharactersCharacterIdCspaAcceptLanguageEnum];
