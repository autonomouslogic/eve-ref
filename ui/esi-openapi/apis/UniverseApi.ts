/* tslint:disable */
/* eslint-disable */
/**
 * EVE Stable Infrastructure (ESI) - tranquility
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2025-12-16
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  UniverseAncestriesGetInner,
  UniverseAsteroidBeltsAsteroidBeltIdGet,
  UniverseBloodlinesGetInner,
  UniverseCategoriesCategoryIdGet,
  UniverseConstellationsConstellationIdGet,
  UniverseFactionsGetInner,
  UniverseGraphicsGraphicIdGet,
  UniverseGroupsGroupIdGet,
  UniverseIdsPost,
  UniverseMoonsMoonIdGet,
  UniverseNamesPostInner,
  UniversePlanetsPlanetIdGet,
  UniverseRacesGetInner,
  UniverseRegionsRegionIdGet,
  UniverseStargatesStargateIdGet,
  UniverseStarsStarIdGet,
  UniverseStationsStationIdGet,
  UniverseStructuresStructureIdGet,
  UniverseSystemJumpsGetInner,
  UniverseSystemKillsGetInner,
  UniverseSystemsSystemIdGet,
  UniverseTypesTypeIdGet,
} from '../models/index';
import {
    UniverseAncestriesGetInnerFromJSON,
    UniverseAncestriesGetInnerToJSON,
    UniverseAsteroidBeltsAsteroidBeltIdGetFromJSON,
    UniverseAsteroidBeltsAsteroidBeltIdGetToJSON,
    UniverseBloodlinesGetInnerFromJSON,
    UniverseBloodlinesGetInnerToJSON,
    UniverseCategoriesCategoryIdGetFromJSON,
    UniverseCategoriesCategoryIdGetToJSON,
    UniverseConstellationsConstellationIdGetFromJSON,
    UniverseConstellationsConstellationIdGetToJSON,
    UniverseFactionsGetInnerFromJSON,
    UniverseFactionsGetInnerToJSON,
    UniverseGraphicsGraphicIdGetFromJSON,
    UniverseGraphicsGraphicIdGetToJSON,
    UniverseGroupsGroupIdGetFromJSON,
    UniverseGroupsGroupIdGetToJSON,
    UniverseIdsPostFromJSON,
    UniverseIdsPostToJSON,
    UniverseMoonsMoonIdGetFromJSON,
    UniverseMoonsMoonIdGetToJSON,
    UniverseNamesPostInnerFromJSON,
    UniverseNamesPostInnerToJSON,
    UniversePlanetsPlanetIdGetFromJSON,
    UniversePlanetsPlanetIdGetToJSON,
    UniverseRacesGetInnerFromJSON,
    UniverseRacesGetInnerToJSON,
    UniverseRegionsRegionIdGetFromJSON,
    UniverseRegionsRegionIdGetToJSON,
    UniverseStargatesStargateIdGetFromJSON,
    UniverseStargatesStargateIdGetToJSON,
    UniverseStarsStarIdGetFromJSON,
    UniverseStarsStarIdGetToJSON,
    UniverseStationsStationIdGetFromJSON,
    UniverseStationsStationIdGetToJSON,
    UniverseStructuresStructureIdGetFromJSON,
    UniverseStructuresStructureIdGetToJSON,
    UniverseSystemJumpsGetInnerFromJSON,
    UniverseSystemJumpsGetInnerToJSON,
    UniverseSystemKillsGetInnerFromJSON,
    UniverseSystemKillsGetInnerToJSON,
    UniverseSystemsSystemIdGetFromJSON,
    UniverseSystemsSystemIdGetToJSON,
    UniverseTypesTypeIdGetFromJSON,
    UniverseTypesTypeIdGetToJSON,
} from '../models/index';

export interface GetUniverseAncestriesRequest {
    xCompatibilityDate: GetUniverseAncestriesXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseAsteroidBeltsAsteroidBeltIdRequest {
    asteroidBeltId: number;
    xCompatibilityDate: GetUniverseAsteroidBeltsAsteroidBeltIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseAsteroidBeltsAsteroidBeltIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseBloodlinesRequest {
    xCompatibilityDate: GetUniverseBloodlinesXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseCategoriesRequest {
    xCompatibilityDate: GetUniverseCategoriesXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseCategoriesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseCategoriesCategoryIdRequest {
    categoryId: number;
    xCompatibilityDate: GetUniverseCategoriesCategoryIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseConstellationsRequest {
    xCompatibilityDate: GetUniverseConstellationsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseConstellationsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseConstellationsConstellationIdRequest {
    constellationId: number;
    xCompatibilityDate: GetUniverseConstellationsConstellationIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseFactionsRequest {
    xCompatibilityDate: GetUniverseFactionsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseGraphicsRequest {
    xCompatibilityDate: GetUniverseGraphicsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseGraphicsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseGraphicsGraphicIdRequest {
    graphicId: number;
    xCompatibilityDate: GetUniverseGraphicsGraphicIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseGraphicsGraphicIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseGroupsRequest {
    xCompatibilityDate: GetUniverseGroupsXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetUniverseGroupsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseGroupsGroupIdRequest {
    groupId: number;
    xCompatibilityDate: GetUniverseGroupsGroupIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseMoonsMoonIdRequest {
    moonId: number;
    xCompatibilityDate: GetUniverseMoonsMoonIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseMoonsMoonIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniversePlanetsPlanetIdRequest {
    planetId: number;
    xCompatibilityDate: GetUniversePlanetsPlanetIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniversePlanetsPlanetIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseRacesRequest {
    xCompatibilityDate: GetUniverseRacesXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseRacesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseRegionsRequest {
    xCompatibilityDate: GetUniverseRegionsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseRegionsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseRegionsRegionIdRequest {
    regionId: number;
    xCompatibilityDate: GetUniverseRegionsRegionIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseStargatesStargateIdRequest {
    stargateId: number;
    xCompatibilityDate: GetUniverseStargatesStargateIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseStargatesStargateIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseStarsStarIdRequest {
    starId: number;
    xCompatibilityDate: GetUniverseStarsStarIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseStarsStarIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseStationsStationIdRequest {
    stationId: number;
    xCompatibilityDate: GetUniverseStationsStationIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseStationsStationIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseStructuresRequest {
    xCompatibilityDate: GetUniverseStructuresXCompatibilityDateEnum;
    filter?: GetUniverseStructuresFilterEnum;
    acceptLanguage?: GetUniverseStructuresAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseStructuresStructureIdRequest {
    structureId: number;
    xCompatibilityDate: GetUniverseStructuresStructureIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseStructuresStructureIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseSystemJumpsRequest {
    xCompatibilityDate: GetUniverseSystemJumpsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseSystemJumpsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseSystemKillsRequest {
    xCompatibilityDate: GetUniverseSystemKillsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseSystemKillsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseSystemsRequest {
    xCompatibilityDate: GetUniverseSystemsXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseSystemsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseSystemsSystemIdRequest {
    systemId: number;
    xCompatibilityDate: GetUniverseSystemsSystemIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseTypesRequest {
    xCompatibilityDate: GetUniverseTypesXCompatibilityDateEnum;
    page?: number;
    acceptLanguage?: GetUniverseTypesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface GetUniverseTypesTypeIdRequest {
    typeId: number;
    xCompatibilityDate: GetUniverseTypesTypeIdXCompatibilityDateEnum;
    acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface PostUniverseIdsRequest {
    xCompatibilityDate: PostUniverseIdsXCompatibilityDateEnum;
    requestBody: Set<string>;
    acceptLanguage?: PostUniverseIdsAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

export interface PostUniverseNamesRequest {
    xCompatibilityDate: PostUniverseNamesXCompatibilityDateEnum;
    requestBody: Set<number>;
    acceptLanguage?: PostUniverseNamesAcceptLanguageEnum;
    ifNoneMatch?: string;
    xTenant?: string;
}

/**
 * 
 */
export class UniverseApi extends runtime.BaseAPI {

    /**
     * Get all character ancestries  This route expires daily at 11:05
     * Get ancestries
     */
    async getUniverseAncestriesRaw(requestParameters: GetUniverseAncestriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseAncestriesGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseAncestries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/ancestries`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseAncestriesGetInnerFromJSON));
    }

    /**
     * Get all character ancestries  This route expires daily at 11:05
     * Get ancestries
     */
    async getUniverseAncestries(requestParameters: GetUniverseAncestriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseAncestriesGetInner>> {
        const response = await this.getUniverseAncestriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on an asteroid belt  This route expires daily at 11:05
     * Get asteroid belt information
     */
    async getUniverseAsteroidBeltsAsteroidBeltIdRaw(requestParameters: GetUniverseAsteroidBeltsAsteroidBeltIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseAsteroidBeltsAsteroidBeltIdGet>> {
        if (requestParameters['asteroidBeltId'] == null) {
            throw new runtime.RequiredError(
                'asteroidBeltId',
                'Required parameter "asteroidBeltId" was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/asteroid_belts/{asteroid_belt_id}`;
        urlPath = urlPath.replace(`{${"asteroid_belt_id"}}`, encodeURIComponent(String(requestParameters['asteroidBeltId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseAsteroidBeltsAsteroidBeltIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on an asteroid belt  This route expires daily at 11:05
     * Get asteroid belt information
     */
    async getUniverseAsteroidBeltsAsteroidBeltId(requestParameters: GetUniverseAsteroidBeltsAsteroidBeltIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseAsteroidBeltsAsteroidBeltIdGet> {
        const response = await this.getUniverseAsteroidBeltsAsteroidBeltIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of bloodlines  This route expires daily at 11:05
     * Get bloodlines
     */
    async getUniverseBloodlinesRaw(requestParameters: GetUniverseBloodlinesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseBloodlinesGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseBloodlines().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/bloodlines`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseBloodlinesGetInnerFromJSON));
    }

    /**
     * Get a list of bloodlines  This route expires daily at 11:05
     * Get bloodlines
     */
    async getUniverseBloodlines(requestParameters: GetUniverseBloodlinesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseBloodlinesGetInner>> {
        const response = await this.getUniverseBloodlinesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of item categories  This route expires daily at 11:05
     * Get item categories
     */
    async getUniverseCategoriesRaw(requestParameters: GetUniverseCategoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseCategories().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/categories`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of item categories  This route expires daily at 11:05
     * Get item categories
     */
    async getUniverseCategories(requestParameters: GetUniverseCategoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseCategoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information of an item category  This route expires daily at 11:05
     * Get item category information
     */
    async getUniverseCategoriesCategoryIdRaw(requestParameters: GetUniverseCategoriesCategoryIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseCategoriesCategoryIdGet>> {
        if (requestParameters['categoryId'] == null) {
            throw new runtime.RequiredError(
                'categoryId',
                'Required parameter "categoryId" was null or undefined when calling getUniverseCategoriesCategoryId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseCategoriesCategoryId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/categories/{category_id}`;
        urlPath = urlPath.replace(`{${"category_id"}}`, encodeURIComponent(String(requestParameters['categoryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseCategoriesCategoryIdGetFromJSON(jsonValue));
    }

    /**
     * Get information of an item category  This route expires daily at 11:05
     * Get item category information
     */
    async getUniverseCategoriesCategoryId(requestParameters: GetUniverseCategoriesCategoryIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseCategoriesCategoryIdGet> {
        const response = await this.getUniverseCategoriesCategoryIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of constellations  This route expires daily at 11:05
     * Get constellations
     */
    async getUniverseConstellationsRaw(requestParameters: GetUniverseConstellationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseConstellations().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/constellations`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of constellations  This route expires daily at 11:05
     * Get constellations
     */
    async getUniverseConstellations(requestParameters: GetUniverseConstellationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseConstellationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a constellation  This route expires daily at 11:05
     * Get constellation information
     */
    async getUniverseConstellationsConstellationIdRaw(requestParameters: GetUniverseConstellationsConstellationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseConstellationsConstellationIdGet>> {
        if (requestParameters['constellationId'] == null) {
            throw new runtime.RequiredError(
                'constellationId',
                'Required parameter "constellationId" was null or undefined when calling getUniverseConstellationsConstellationId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseConstellationsConstellationId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/constellations/{constellation_id}`;
        urlPath = urlPath.replace(`{${"constellation_id"}}`, encodeURIComponent(String(requestParameters['constellationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseConstellationsConstellationIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a constellation  This route expires daily at 11:05
     * Get constellation information
     */
    async getUniverseConstellationsConstellationId(requestParameters: GetUniverseConstellationsConstellationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseConstellationsConstellationIdGet> {
        const response = await this.getUniverseConstellationsConstellationIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of factions  This route expires daily at 11:05
     * Get factions
     */
    async getUniverseFactionsRaw(requestParameters: GetUniverseFactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseFactionsGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseFactions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/factions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseFactionsGetInnerFromJSON));
    }

    /**
     * Get a list of factions  This route expires daily at 11:05
     * Get factions
     */
    async getUniverseFactions(requestParameters: GetUniverseFactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseFactionsGetInner>> {
        const response = await this.getUniverseFactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of graphics  This route expires daily at 11:05
     * Get graphics
     */
    async getUniverseGraphicsRaw(requestParameters: GetUniverseGraphicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseGraphics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/graphics`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of graphics  This route expires daily at 11:05
     * Get graphics
     */
    async getUniverseGraphics(requestParameters: GetUniverseGraphicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseGraphicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a graphic  This route expires daily at 11:05
     * Get graphic information
     */
    async getUniverseGraphicsGraphicIdRaw(requestParameters: GetUniverseGraphicsGraphicIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseGraphicsGraphicIdGet>> {
        if (requestParameters['graphicId'] == null) {
            throw new runtime.RequiredError(
                'graphicId',
                'Required parameter "graphicId" was null or undefined when calling getUniverseGraphicsGraphicId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseGraphicsGraphicId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/graphics/{graphic_id}`;
        urlPath = urlPath.replace(`{${"graphic_id"}}`, encodeURIComponent(String(requestParameters['graphicId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseGraphicsGraphicIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a graphic  This route expires daily at 11:05
     * Get graphic information
     */
    async getUniverseGraphicsGraphicId(requestParameters: GetUniverseGraphicsGraphicIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseGraphicsGraphicIdGet> {
        const response = await this.getUniverseGraphicsGraphicIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of item groups  This route expires daily at 11:05
     * Get item groups
     */
    async getUniverseGroupsRaw(requestParameters: GetUniverseGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseGroups().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/groups`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of item groups  This route expires daily at 11:05
     * Get item groups
     */
    async getUniverseGroups(requestParameters: GetUniverseGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on an item group  This route expires daily at 11:05
     * Get item group information
     */
    async getUniverseGroupsGroupIdRaw(requestParameters: GetUniverseGroupsGroupIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseGroupsGroupIdGet>> {
        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling getUniverseGroupsGroupId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseGroupsGroupId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/groups/{group_id}`;
        urlPath = urlPath.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseGroupsGroupIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on an item group  This route expires daily at 11:05
     * Get item group information
     */
    async getUniverseGroupsGroupId(requestParameters: GetUniverseGroupsGroupIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseGroupsGroupIdGet> {
        const response = await this.getUniverseGroupsGroupIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a moon  This route expires daily at 11:05
     * Get moon information
     */
    async getUniverseMoonsMoonIdRaw(requestParameters: GetUniverseMoonsMoonIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseMoonsMoonIdGet>> {
        if (requestParameters['moonId'] == null) {
            throw new runtime.RequiredError(
                'moonId',
                'Required parameter "moonId" was null or undefined when calling getUniverseMoonsMoonId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseMoonsMoonId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/moons/{moon_id}`;
        urlPath = urlPath.replace(`{${"moon_id"}}`, encodeURIComponent(String(requestParameters['moonId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseMoonsMoonIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a moon  This route expires daily at 11:05
     * Get moon information
     */
    async getUniverseMoonsMoonId(requestParameters: GetUniverseMoonsMoonIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseMoonsMoonIdGet> {
        const response = await this.getUniverseMoonsMoonIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a planet  This route expires daily at 11:05
     * Get planet information
     */
    async getUniversePlanetsPlanetIdRaw(requestParameters: GetUniversePlanetsPlanetIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniversePlanetsPlanetIdGet>> {
        if (requestParameters['planetId'] == null) {
            throw new runtime.RequiredError(
                'planetId',
                'Required parameter "planetId" was null or undefined when calling getUniversePlanetsPlanetId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniversePlanetsPlanetId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/planets/{planet_id}`;
        urlPath = urlPath.replace(`{${"planet_id"}}`, encodeURIComponent(String(requestParameters['planetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniversePlanetsPlanetIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a planet  This route expires daily at 11:05
     * Get planet information
     */
    async getUniversePlanetsPlanetId(requestParameters: GetUniversePlanetsPlanetIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniversePlanetsPlanetIdGet> {
        const response = await this.getUniversePlanetsPlanetIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of character races  This route expires daily at 11:05
     * Get character races
     */
    async getUniverseRacesRaw(requestParameters: GetUniverseRacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseRacesGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseRaces().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/races`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseRacesGetInnerFromJSON));
    }

    /**
     * Get a list of character races  This route expires daily at 11:05
     * Get character races
     */
    async getUniverseRaces(requestParameters: GetUniverseRacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseRacesGetInner>> {
        const response = await this.getUniverseRacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of regions  This route expires daily at 11:05
     * Get regions
     */
    async getUniverseRegionsRaw(requestParameters: GetUniverseRegionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseRegions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/regions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of regions  This route expires daily at 11:05
     * Get regions
     */
    async getUniverseRegions(requestParameters: GetUniverseRegionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseRegionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a region  This route expires daily at 11:05
     * Get region information
     */
    async getUniverseRegionsRegionIdRaw(requestParameters: GetUniverseRegionsRegionIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseRegionsRegionIdGet>> {
        if (requestParameters['regionId'] == null) {
            throw new runtime.RequiredError(
                'regionId',
                'Required parameter "regionId" was null or undefined when calling getUniverseRegionsRegionId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseRegionsRegionId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/regions/{region_id}`;
        urlPath = urlPath.replace(`{${"region_id"}}`, encodeURIComponent(String(requestParameters['regionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseRegionsRegionIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a region  This route expires daily at 11:05
     * Get region information
     */
    async getUniverseRegionsRegionId(requestParameters: GetUniverseRegionsRegionIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseRegionsRegionIdGet> {
        const response = await this.getUniverseRegionsRegionIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a stargate  This route expires daily at 11:05
     * Get stargate information
     */
    async getUniverseStargatesStargateIdRaw(requestParameters: GetUniverseStargatesStargateIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseStargatesStargateIdGet>> {
        if (requestParameters['stargateId'] == null) {
            throw new runtime.RequiredError(
                'stargateId',
                'Required parameter "stargateId" was null or undefined when calling getUniverseStargatesStargateId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseStargatesStargateId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/stargates/{stargate_id}`;
        urlPath = urlPath.replace(`{${"stargate_id"}}`, encodeURIComponent(String(requestParameters['stargateId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseStargatesStargateIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a stargate  This route expires daily at 11:05
     * Get stargate information
     */
    async getUniverseStargatesStargateId(requestParameters: GetUniverseStargatesStargateIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseStargatesStargateIdGet> {
        const response = await this.getUniverseStargatesStargateIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a star  This route expires daily at 11:05
     * Get star information
     */
    async getUniverseStarsStarIdRaw(requestParameters: GetUniverseStarsStarIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseStarsStarIdGet>> {
        if (requestParameters['starId'] == null) {
            throw new runtime.RequiredError(
                'starId',
                'Required parameter "starId" was null or undefined when calling getUniverseStarsStarId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseStarsStarId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/stars/{star_id}`;
        urlPath = urlPath.replace(`{${"star_id"}}`, encodeURIComponent(String(requestParameters['starId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseStarsStarIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a star  This route expires daily at 11:05
     * Get star information
     */
    async getUniverseStarsStarId(requestParameters: GetUniverseStarsStarIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseStarsStarIdGet> {
        const response = await this.getUniverseStarsStarIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a station  This route expires daily at 11:05
     * Get station information
     */
    async getUniverseStationsStationIdRaw(requestParameters: GetUniverseStationsStationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseStationsStationIdGet>> {
        if (requestParameters['stationId'] == null) {
            throw new runtime.RequiredError(
                'stationId',
                'Required parameter "stationId" was null or undefined when calling getUniverseStationsStationId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseStationsStationId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/stations/{station_id}`;
        urlPath = urlPath.replace(`{${"station_id"}}`, encodeURIComponent(String(requestParameters['stationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseStationsStationIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a station  This route expires daily at 11:05
     * Get station information
     */
    async getUniverseStationsStationId(requestParameters: GetUniverseStationsStationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseStationsStationIdGet> {
        const response = await this.getUniverseStationsStationIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all public structures
     * List all public structures
     */
    async getUniverseStructuresRaw(requestParameters: GetUniverseStructuresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Set<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseStructures().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/structures`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List all public structures
     * List all public structures
     */
    async getUniverseStructures(requestParameters: GetUniverseStructuresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Set<number>> {
        const response = await this.getUniverseStructuresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.
     * Get structure information
     */
    async getUniverseStructuresStructureIdRaw(requestParameters: GetUniverseStructuresStructureIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseStructuresStructureIdGet>> {
        if (requestParameters['structureId'] == null) {
            throw new runtime.RequiredError(
                'structureId',
                'Required parameter "structureId" was null or undefined when calling getUniverseStructuresStructureId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseStructuresStructureId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["esi-universe.read_structures.v1"]);
        }


        let urlPath = `/universe/structures/{structure_id}`;
        urlPath = urlPath.replace(`{${"structure_id"}}`, encodeURIComponent(String(requestParameters['structureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseStructuresStructureIdGetFromJSON(jsonValue));
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.
     * Get structure information
     */
    async getUniverseStructuresStructureId(requestParameters: GetUniverseStructuresStructureIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseStructuresStructureIdGet> {
        const response = await this.getUniverseStructuresStructureIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed
     * Get system jumps
     */
    async getUniverseSystemJumpsRaw(requestParameters: GetUniverseSystemJumpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseSystemJumpsGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseSystemJumps().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/system_jumps`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseSystemJumpsGetInnerFromJSON));
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed
     * Get system jumps
     */
    async getUniverseSystemJumps(requestParameters: GetUniverseSystemJumpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseSystemJumpsGetInner>> {
        const response = await this.getUniverseSystemJumpsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed
     * Get system kills
     */
    async getUniverseSystemKillsRaw(requestParameters: GetUniverseSystemKillsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseSystemKillsGetInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseSystemKills().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/system_kills`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseSystemKillsGetInnerFromJSON));
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed
     * Get system kills
     */
    async getUniverseSystemKills(requestParameters: GetUniverseSystemKillsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseSystemKillsGetInner>> {
        const response = await this.getUniverseSystemKillsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of solar systems  This route expires daily at 11:05
     * Get solar systems
     */
    async getUniverseSystemsRaw(requestParameters: GetUniverseSystemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseSystems().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/systems`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of solar systems  This route expires daily at 11:05
     * Get solar systems
     */
    async getUniverseSystems(requestParameters: GetUniverseSystemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseSystemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a solar system.  This route expires daily at 11:05
     * Get solar system information
     */
    async getUniverseSystemsSystemIdRaw(requestParameters: GetUniverseSystemsSystemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseSystemsSystemIdGet>> {
        if (requestParameters['systemId'] == null) {
            throw new runtime.RequiredError(
                'systemId',
                'Required parameter "systemId" was null or undefined when calling getUniverseSystemsSystemId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseSystemsSystemId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/systems/{system_id}`;
        urlPath = urlPath.replace(`{${"system_id"}}`, encodeURIComponent(String(requestParameters['systemId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseSystemsSystemIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a solar system.  This route expires daily at 11:05
     * Get solar system information
     */
    async getUniverseSystemsSystemId(requestParameters: GetUniverseSystemsSystemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseSystemsSystemIdGet> {
        const response = await this.getUniverseSystemsSystemIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of type ids  This route expires daily at 11:05
     * Get types
     */
    async getUniverseTypesRaw(requestParameters: GetUniverseTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseTypes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/types`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of type ids  This route expires daily at 11:05
     * Get types
     */
    async getUniverseTypes(requestParameters: GetUniverseTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getUniverseTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information on a type  This route expires daily at 11:05
     * Get type information
     */
    async getUniverseTypesTypeIdRaw(requestParameters: GetUniverseTypesTypeIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseTypesTypeIdGet>> {
        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling getUniverseTypesTypeId().'
            );
        }

        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling getUniverseTypesTypeId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/types/{type_id}`;
        urlPath = urlPath.replace(`{${"type_id"}}`, encodeURIComponent(String(requestParameters['typeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseTypesTypeIdGetFromJSON(jsonValue));
    }

    /**
     * Get information on a type  This route expires daily at 11:05
     * Get type information
     */
    async getUniverseTypesTypeId(requestParameters: GetUniverseTypesTypeIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseTypesTypeIdGet> {
        const response = await this.getUniverseTypesTypeIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours
     * Bulk names to IDs
     */
    async postUniverseIdsRaw(requestParameters: PostUniverseIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UniverseIdsPost>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling postUniverseIds().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling postUniverseIds().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/ids`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UniverseIdsPostFromJSON(jsonValue));
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours
     * Bulk names to IDs
     */
    async postUniverseIds(requestParameters: PostUniverseIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UniverseIdsPost> {
        const response = await this.postUniverseIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions
     * Get names and categories for a set of IDs
     */
    async postUniverseNamesRaw(requestParameters: PostUniverseNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UniverseNamesPostInner>>> {
        if (requestParameters['xCompatibilityDate'] == null) {
            throw new runtime.RequiredError(
                'xCompatibilityDate',
                'Required parameter "xCompatibilityDate" was null or undefined when calling postUniverseNames().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling postUniverseNames().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['acceptLanguage'] != null) {
            headerParameters['Accept-Language'] = String(requestParameters['acceptLanguage']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (requestParameters['xCompatibilityDate'] != null) {
            headerParameters['X-Compatibility-Date'] = String(requestParameters['xCompatibilityDate']);
        }

        if (requestParameters['xTenant'] != null) {
            headerParameters['X-Tenant'] = String(requestParameters['xTenant']);
        }


        let urlPath = `/universe/names`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UniverseNamesPostInnerFromJSON));
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions
     * Get names and categories for a set of IDs
     */
    async postUniverseNames(requestParameters: PostUniverseNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UniverseNamesPostInner>> {
        const response = await this.postUniverseNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetUniverseAncestriesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseAncestriesXCompatibilityDateEnum = typeof GetUniverseAncestriesXCompatibilityDateEnum[keyof typeof GetUniverseAncestriesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseAncestriesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseAncestriesAcceptLanguageEnum = typeof GetUniverseAncestriesAcceptLanguageEnum[keyof typeof GetUniverseAncestriesAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseAsteroidBeltsAsteroidBeltIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseAsteroidBeltsAsteroidBeltIdXCompatibilityDateEnum = typeof GetUniverseAsteroidBeltsAsteroidBeltIdXCompatibilityDateEnum[keyof typeof GetUniverseAsteroidBeltsAsteroidBeltIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseAsteroidBeltsAsteroidBeltIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseAsteroidBeltsAsteroidBeltIdAcceptLanguageEnum = typeof GetUniverseAsteroidBeltsAsteroidBeltIdAcceptLanguageEnum[keyof typeof GetUniverseAsteroidBeltsAsteroidBeltIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseBloodlinesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseBloodlinesXCompatibilityDateEnum = typeof GetUniverseBloodlinesXCompatibilityDateEnum[keyof typeof GetUniverseBloodlinesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseBloodlinesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseBloodlinesAcceptLanguageEnum = typeof GetUniverseBloodlinesAcceptLanguageEnum[keyof typeof GetUniverseBloodlinesAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseCategoriesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseCategoriesXCompatibilityDateEnum = typeof GetUniverseCategoriesXCompatibilityDateEnum[keyof typeof GetUniverseCategoriesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseCategoriesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseCategoriesAcceptLanguageEnum = typeof GetUniverseCategoriesAcceptLanguageEnum[keyof typeof GetUniverseCategoriesAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseCategoriesCategoryIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseCategoriesCategoryIdXCompatibilityDateEnum = typeof GetUniverseCategoriesCategoryIdXCompatibilityDateEnum[keyof typeof GetUniverseCategoriesCategoryIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseCategoriesCategoryIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseCategoriesCategoryIdAcceptLanguageEnum = typeof GetUniverseCategoriesCategoryIdAcceptLanguageEnum[keyof typeof GetUniverseCategoriesCategoryIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseConstellationsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseConstellationsXCompatibilityDateEnum = typeof GetUniverseConstellationsXCompatibilityDateEnum[keyof typeof GetUniverseConstellationsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseConstellationsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseConstellationsAcceptLanguageEnum = typeof GetUniverseConstellationsAcceptLanguageEnum[keyof typeof GetUniverseConstellationsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseConstellationsConstellationIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseConstellationsConstellationIdXCompatibilityDateEnum = typeof GetUniverseConstellationsConstellationIdXCompatibilityDateEnum[keyof typeof GetUniverseConstellationsConstellationIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseConstellationsConstellationIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseConstellationsConstellationIdAcceptLanguageEnum = typeof GetUniverseConstellationsConstellationIdAcceptLanguageEnum[keyof typeof GetUniverseConstellationsConstellationIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseFactionsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseFactionsXCompatibilityDateEnum = typeof GetUniverseFactionsXCompatibilityDateEnum[keyof typeof GetUniverseFactionsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseFactionsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseFactionsAcceptLanguageEnum = typeof GetUniverseFactionsAcceptLanguageEnum[keyof typeof GetUniverseFactionsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseGraphicsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseGraphicsXCompatibilityDateEnum = typeof GetUniverseGraphicsXCompatibilityDateEnum[keyof typeof GetUniverseGraphicsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseGraphicsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGraphicsAcceptLanguageEnum = typeof GetUniverseGraphicsAcceptLanguageEnum[keyof typeof GetUniverseGraphicsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseGraphicsGraphicIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseGraphicsGraphicIdXCompatibilityDateEnum = typeof GetUniverseGraphicsGraphicIdXCompatibilityDateEnum[keyof typeof GetUniverseGraphicsGraphicIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseGraphicsGraphicIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGraphicsGraphicIdAcceptLanguageEnum = typeof GetUniverseGraphicsGraphicIdAcceptLanguageEnum[keyof typeof GetUniverseGraphicsGraphicIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseGroupsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseGroupsXCompatibilityDateEnum = typeof GetUniverseGroupsXCompatibilityDateEnum[keyof typeof GetUniverseGroupsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseGroupsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGroupsAcceptLanguageEnum = typeof GetUniverseGroupsAcceptLanguageEnum[keyof typeof GetUniverseGroupsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseGroupsGroupIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseGroupsGroupIdXCompatibilityDateEnum = typeof GetUniverseGroupsGroupIdXCompatibilityDateEnum[keyof typeof GetUniverseGroupsGroupIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseGroupsGroupIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGroupsGroupIdAcceptLanguageEnum = typeof GetUniverseGroupsGroupIdAcceptLanguageEnum[keyof typeof GetUniverseGroupsGroupIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseMoonsMoonIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseMoonsMoonIdXCompatibilityDateEnum = typeof GetUniverseMoonsMoonIdXCompatibilityDateEnum[keyof typeof GetUniverseMoonsMoonIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseMoonsMoonIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseMoonsMoonIdAcceptLanguageEnum = typeof GetUniverseMoonsMoonIdAcceptLanguageEnum[keyof typeof GetUniverseMoonsMoonIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniversePlanetsPlanetIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniversePlanetsPlanetIdXCompatibilityDateEnum = typeof GetUniversePlanetsPlanetIdXCompatibilityDateEnum[keyof typeof GetUniversePlanetsPlanetIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniversePlanetsPlanetIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniversePlanetsPlanetIdAcceptLanguageEnum = typeof GetUniversePlanetsPlanetIdAcceptLanguageEnum[keyof typeof GetUniversePlanetsPlanetIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseRacesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseRacesXCompatibilityDateEnum = typeof GetUniverseRacesXCompatibilityDateEnum[keyof typeof GetUniverseRacesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseRacesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRacesAcceptLanguageEnum = typeof GetUniverseRacesAcceptLanguageEnum[keyof typeof GetUniverseRacesAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseRegionsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseRegionsXCompatibilityDateEnum = typeof GetUniverseRegionsXCompatibilityDateEnum[keyof typeof GetUniverseRegionsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseRegionsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRegionsAcceptLanguageEnum = typeof GetUniverseRegionsAcceptLanguageEnum[keyof typeof GetUniverseRegionsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseRegionsRegionIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseRegionsRegionIdXCompatibilityDateEnum = typeof GetUniverseRegionsRegionIdXCompatibilityDateEnum[keyof typeof GetUniverseRegionsRegionIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseRegionsRegionIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRegionsRegionIdAcceptLanguageEnum = typeof GetUniverseRegionsRegionIdAcceptLanguageEnum[keyof typeof GetUniverseRegionsRegionIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseStargatesStargateIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseStargatesStargateIdXCompatibilityDateEnum = typeof GetUniverseStargatesStargateIdXCompatibilityDateEnum[keyof typeof GetUniverseStargatesStargateIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseStargatesStargateIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseStargatesStargateIdAcceptLanguageEnum = typeof GetUniverseStargatesStargateIdAcceptLanguageEnum[keyof typeof GetUniverseStargatesStargateIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseStarsStarIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseStarsStarIdXCompatibilityDateEnum = typeof GetUniverseStarsStarIdXCompatibilityDateEnum[keyof typeof GetUniverseStarsStarIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseStarsStarIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseStarsStarIdAcceptLanguageEnum = typeof GetUniverseStarsStarIdAcceptLanguageEnum[keyof typeof GetUniverseStarsStarIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseStationsStationIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseStationsStationIdXCompatibilityDateEnum = typeof GetUniverseStationsStationIdXCompatibilityDateEnum[keyof typeof GetUniverseStationsStationIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseStationsStationIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseStationsStationIdAcceptLanguageEnum = typeof GetUniverseStationsStationIdAcceptLanguageEnum[keyof typeof GetUniverseStationsStationIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseStructuresXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseStructuresXCompatibilityDateEnum = typeof GetUniverseStructuresXCompatibilityDateEnum[keyof typeof GetUniverseStructuresXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseStructuresFilterEnum = {
    Market: 'market',
    ManufacturingBasic: 'manufacturing_basic'
} as const;
export type GetUniverseStructuresFilterEnum = typeof GetUniverseStructuresFilterEnum[keyof typeof GetUniverseStructuresFilterEnum];
/**
 * @export
 */
export const GetUniverseStructuresAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseStructuresAcceptLanguageEnum = typeof GetUniverseStructuresAcceptLanguageEnum[keyof typeof GetUniverseStructuresAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseStructuresStructureIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseStructuresStructureIdXCompatibilityDateEnum = typeof GetUniverseStructuresStructureIdXCompatibilityDateEnum[keyof typeof GetUniverseStructuresStructureIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseStructuresStructureIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseStructuresStructureIdAcceptLanguageEnum = typeof GetUniverseStructuresStructureIdAcceptLanguageEnum[keyof typeof GetUniverseStructuresStructureIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseSystemJumpsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseSystemJumpsXCompatibilityDateEnum = typeof GetUniverseSystemJumpsXCompatibilityDateEnum[keyof typeof GetUniverseSystemJumpsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseSystemJumpsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemJumpsAcceptLanguageEnum = typeof GetUniverseSystemJumpsAcceptLanguageEnum[keyof typeof GetUniverseSystemJumpsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseSystemKillsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseSystemKillsXCompatibilityDateEnum = typeof GetUniverseSystemKillsXCompatibilityDateEnum[keyof typeof GetUniverseSystemKillsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseSystemKillsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemKillsAcceptLanguageEnum = typeof GetUniverseSystemKillsAcceptLanguageEnum[keyof typeof GetUniverseSystemKillsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseSystemsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseSystemsXCompatibilityDateEnum = typeof GetUniverseSystemsXCompatibilityDateEnum[keyof typeof GetUniverseSystemsXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseSystemsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemsAcceptLanguageEnum = typeof GetUniverseSystemsAcceptLanguageEnum[keyof typeof GetUniverseSystemsAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseSystemsSystemIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseSystemsSystemIdXCompatibilityDateEnum = typeof GetUniverseSystemsSystemIdXCompatibilityDateEnum[keyof typeof GetUniverseSystemsSystemIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseSystemsSystemIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemsSystemIdAcceptLanguageEnum = typeof GetUniverseSystemsSystemIdAcceptLanguageEnum[keyof typeof GetUniverseSystemsSystemIdAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseTypesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseTypesXCompatibilityDateEnum = typeof GetUniverseTypesXCompatibilityDateEnum[keyof typeof GetUniverseTypesXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseTypesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseTypesAcceptLanguageEnum = typeof GetUniverseTypesAcceptLanguageEnum[keyof typeof GetUniverseTypesAcceptLanguageEnum];
/**
 * @export
 */
export const GetUniverseTypesTypeIdXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type GetUniverseTypesTypeIdXCompatibilityDateEnum = typeof GetUniverseTypesTypeIdXCompatibilityDateEnum[keyof typeof GetUniverseTypesTypeIdXCompatibilityDateEnum];
/**
 * @export
 */
export const GetUniverseTypesTypeIdAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseTypesTypeIdAcceptLanguageEnum = typeof GetUniverseTypesTypeIdAcceptLanguageEnum[keyof typeof GetUniverseTypesTypeIdAcceptLanguageEnum];
/**
 * @export
 */
export const PostUniverseIdsXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type PostUniverseIdsXCompatibilityDateEnum = typeof PostUniverseIdsXCompatibilityDateEnum[keyof typeof PostUniverseIdsXCompatibilityDateEnum];
/**
 * @export
 */
export const PostUniverseIdsAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostUniverseIdsAcceptLanguageEnum = typeof PostUniverseIdsAcceptLanguageEnum[keyof typeof PostUniverseIdsAcceptLanguageEnum];
/**
 * @export
 */
export const PostUniverseNamesXCompatibilityDateEnum = {
    _20251216: '2025-12-16'
} as const;
export type PostUniverseNamesXCompatibilityDateEnum = typeof PostUniverseNamesXCompatibilityDateEnum[keyof typeof PostUniverseNamesXCompatibilityDateEnum];
/**
 * @export
 */
export const PostUniverseNamesAcceptLanguageEnum = {
    En: 'en',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostUniverseNamesAcceptLanguageEnum = typeof PostUniverseNamesAcceptLanguageEnum[keyof typeof PostUniverseNamesAcceptLanguageEnum];
